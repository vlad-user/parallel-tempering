import os
import sys
import pickle
import json

import numpy as np
import matplotlib.pyplot as plt
import pylatex as tex

from simulator.plot import Plot

class ReportGenerator:

  _colors = plt.rcParams['axes.prop_cycle'].by_key()['color']

  def __init__(self, files, labels, file_prefix='rep_gen_'):
    """Creates a new `ReportGenerator` instance.

    Args:
      `files`: A list of lists s.t. each list contains a filenames
        that should be grouped together and showed by the same curve.
      `labels`: A list of strings of labels for legend. Should be
        ordered based on replica id (replica 0 first).
      `file_prefix`: A prefix that will be attached to all files
        generated by this instance (plot pngs and pdfs).
    """

    if not isinstance(files, list) or not files:
      raise ValueError('`files` must be non-empty list.')

    if not isinstance(labels, list) or not labels:
      raise ValueError('`labels` must be non-empty list.')

    if any(not isinstance(f, list) for f in files):
      raise ValueError('Each element in `files` must be a list.')

    if any(not f for f in files):
      raise ValueError('There are empty list in `files`.')

    dirname = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                          'summaries',
                          'reports')

    if not os.path.exists(dirname):
      os.makedirs(dirname)

    self._dirname = os.path.join(dirname, file_prefix)

    if not os.path.exists(self._dirname):
      os.makedirs(self._dirname)

    for f in os.listdir(self._dirname):
      if f.endswith('.pdf') or f.endswith('.tex'):
        os.remove(os.path.join(self._dirname, f))

    self._images_dirname = os.path.join(self._dirname, 'images')

    if not os.path.exists(self._images_dirname):
      os.makedirs(self._images_dirname)

    self._mses = [MultiSummaryExtractor(f) for f in files]
    self._labels = labels
    self._file_prefix = file_prefix

    max_len = max(len(f) for f in files)
    self._linewidths = [2 for i in range(max_len)]
    self._markers = ['o' for i in range(max_len)]

    self._width = r'1\textwidth'
    self._position = 'h'
    self._pdf_filename = os.path.join(self._dirname, self._file_prefix)


  def generate_report(self, custom_text='Results'):
    doc = tex.Document(self._pdf_filename)
    doc.append(custom_text)

    with doc.create(tex.Figure(position=self._position)) as plot_:
      plot_.add_image(self._plot_diffusion_vs_min_error())
      plot_.add_caption('Average min 0-1 error vs average diffusion to achieve this error.')
    plt.close()

    with doc.create(tex.Figure(position=self._position)) as plot_:
      plot_.add_image(self._plot_n_steps_vs_min_error())
      plot_.add_caption('Average min 0-1 error vs average epochs to achieve this error.')
    plt.close()

    doc.generate_pdf(clean_tex=False)

  def _plot_diffusion_vs_min_error(self):
    fig, ax = plt.subplots()
    figs = []
    plot = Plot()
    for i, mse in enumerate(self._mses):
      diff_vals, err_vals, seps = (
          mse.get_diffusion_vs_min_error())
      annotation = [(str(seps[j]), diff_vals[j], err_vals[j])
                    for j in range(len(diff_vals))]

      figs.append(plot.plot(x=diff_vals,
                            y=err_vals,
                            fig=fig,
                            ax=ax,
                            label=self._labels[i],
                            color=self._colors[i],
                            splined_points_mult=None,
                            linewidth=self._linewidths[i],
                            marker=self._markers[i],
                            annotate=annotation))
    plot.legend(fig,
                ax,
                xlabel='AVERAGE DIFFUSION',
                ylabel='AVERAGE MIN 0-1 ERROR',
                fig_width=8,
                fig_height=4,
                bbox_to_anchor=(1.15, 0.5))

    img_path = os.path.join(self._images_dirname, 'diffusion.png')
    fig.savefig(img_path, bbox_inches='tight')
    return img_path

  def _plot_n_steps_vs_min_error(self):
    fig, ax = plt.subplots()
    figs = []
    plot = Plot()
    for i, mse in enumerate(self._mses):
      step_vals, err_vals, seps = (
          mse.get_n_steps_vs_min_error())
      annotation = [(str(seps[j]), step_vals[j], err_vals[j])
                    for j in range(len(step_vals))]
      figs.append(plot.plot(x=step_vals,
                            y=err_vals,
                            fig=fig,
                            ax=ax,
                            label=self._labels[i],
                            color=self._colors[i],
                            splined_points_mult=None,
                            linewidth=self._linewidths[i],
                            marker=self._markers[i],
                            annotate=annotation))
    plot.legend(fig,
                ax,
                xlabel='AVERAGE EPOCHS',
                ylabel='AVERAGE MIN 0-1 ERROR',
                fig_width=8,
                fig_height=4,
                bbox_to_anchor=(1.15, 0.5))

    img_path = os.path.join(self._images_dirname, 'n_steps.png')
    fig.savefig(img_path, bbox_inches='tight')
    return img_path







class MultiSummaryExtractor:

  def __init__(self, names):
    """Instantiates a new MultiSummaryExtractor instance.

    Args:
      `names`: A list of simulation names.

    Raises:
      ValueError: If for any simulation name in `names` the simulation
        do not exist.
      TypeError: If `names` is not `list` or `names` is an empty list.
    """
    dirname = os.path.abspath(os.path.dirname(__file__))
    self._dirname = os.path.join(dirname, 'summaries')
    filenames = os.listdir(self._dirname)
    
    if not isinstance(names, list) or not names:
      raise TypeError("`names` argument must be non-empty list.")
    if any(name not in filenames for name in names):
      raise ValueError('The following simulation(s) do not exist(s):',
                       [name for name in names if name not in filenames])
    self._summ_ext = {
        name:SummaryExtractor(name)
        for name in names
    }

  def get_sep_ratio_vs_accept_ratio(self):
    """Returns data (sep_ratio list, `accept_ratio` list, stddev list)."""

    sep_ratios = []
    accept_ratios = []
    errs = []

    for name in self._summ_ext:
      se = self._summ_ext[name]
      sep, acc, stddev = se.get_sep_ratio_vs_accept_ratio()
      sep_ratios.append(sep)
      accept_ratios.append(sep)
      errs.append(stddev)

    x, y, z = zip(*sorted(zip(sep_ratios, accept_ratios, errs)))

    return list(x), list(y), list(z)

  def get_sep_ratio_vs_mix_ratio(self):
    """Returns data (sep_ratio list, `accept_ratio` list, stddev list)."""

    sep_ratios = []
    mix_ratios = []
    errs = []

    for name in self._summ_ext:
      se = self._summ_ext[name]
      sep, acc, stddev = se.get_sep_ratio_vs_mix_ratio()
      sep_ratios.append(sep)
      mix_ratios.append(sep)
      errs.append(stddev)

    x, y, z = zip(*sorted(zip(sep_ratios, mix_ratios, errs)))

    return list(x), list(y), list(z)

  def get_sep_ratio_vs_visit_ratio(self):
    """Returns data (sep_ratio list, `accept_ratio` list, stddev list)."""

    sep_ratios = []
    visit_ratios = []
    errs = []

    for name in self._summ_ext:
      se = self._summ_ext[name]
      sep, acc, stddev = se.get_sep_ratio_vs_visit_ratio()
      sep_ratios.append(sep)
      visit_ratios.append(sep)
      errs.append(stddev)

    x, y, z = zip(*sorted(zip(sep_ratios, visit_ratios, errs)))

    return list(x), list(y), list(z)

  def get_diffusion_vs_min_error(self):
    sep_ratios = []
    diff_vals = []
    errs = []

    for name in self._summ_ext:
      se = self._summ_ext[name]
      diff_val, diff_err, loss_val, loss_err, sep = (
          se.get_diffusion_vs_min_error())
      sep_ratios.append(sep)
      diff_vals.append(diff_val)
      errs.append(loss_val)

    x, y, z = zip(*sorted(zip(diff_vals, errs, sep_ratios)))

    return list(x), list(y), list(z)

  def get_n_steps_vs_min_error(self):
    sep_ratios = []
    err_vals = []
    step_vals = []


    for name in self._summ_ext:
      se = self._summ_ext[name]
      step_val, step_err, loss_val, loss_err, sep = (
          se.get_n_steps_vs_min_error())
      sep_ratios.append(sep)
      step_vals.append(step_val)
      err_vals.append(loss_val)

    x, y, z = zip(*sorted(zip(step_vals, err_vals, sep_ratios)))

    return list(x), list(y), list(z)


class SummaryExtractor:

  def __init__(self, name):
    dirname = os.path.abspath(os.path.dirname(__file__))
    self._dirname = os.path.join(dirname, 'summaries', name)
    filenames = sorted([f for f in os.listdir(self._dirname) if 'summary' in f],
                       key=lambda x: int(x.split('_')[1].split('.')[0]))
    description_path = os.path.join(self._dirname, 'description.json')
    self._summaries = []
    self._n_simulations = len(filenames)
    for f in filenames:
      with open(os.path.join(self._dirname, f), 'rb', os.O_NONBLOCK) as fo:
        self._summaries.append(pickle.load(fo))

    with open(description_path, 'r') as fo:
      self._description = json.load(fo)

    self._vals = {
        'accept_ratio': None,
        'mix_ratio': None,
        'visit_ratio': None,
        'accept_ratio_err': None,
        'visit_ratio_err': None,
        'avg_min_error': None,
        'avg_min_error_err': None,
        'avg_diff_for_min_error': None,
        'avg_diff_for_min_error_err': None,
        'avg_steps_for_min_error': None, # steps == epochs
        'avg_steps_for_min_error_err': None
    }

    self._n_replicas = self.get_description()['n_replicas']

  def get_diffusion_vs_min_error(self):
    """Returns a min loss and diffusion value to achieve this min loss."""

    if self._vals['avg_min_error'] is None:
      losses = []
      diffs = []
      steps = []
      replicas = []

      for s in range(self._n_simulations):
        candidate_losses = []
        candidate_diffs = []
        candidate_steps = []

        for r in range(self._n_replicas):
          x_loss, y_loss = self.get_summary('test_error', replica_id=r,
                                            simulation_num=s)
          x_diff, y_diff = self.get_summary('diffusion', replica_id=r,
                                            simulation_num=s)
          y_loss = np.asarray(y_loss)
          loss_idx = y_loss.argmin()
          diff_idx = _find_nearest_idx(x_diff, x_loss[loss_idx])
          candidate_losses.append(y_loss[loss_idx])
          candidate_diffs.append(y_diff[diff_idx])
          candidate_steps.append(x_loss[loss_idx])
          

        idx = np.argmin(np.asarray(candidate_losses))
        losses.append(candidate_losses[idx])
        diffs.append(candidate_diffs[idx])
        steps.append(candidate_steps[idx])
        replicas.append(idx)

      loss_val = np.mean(losses)
      loss_err = np.std(losses)
      diff_val = np.mean(diffs)
      diff_err = np.std(diffs)
      step_val = np.mean(steps)
      step_err = np.std(steps)

      self._vals['avg_min_error'] = loss_val
      self._vals['avg_min_error_err'] = loss_err
      self._vals['avg_diff_for_min_error'] = diff_val
      self._vals['avg_diff_for_min_error_err'] = diff_err
      self._vals['avg_steps_for_min_error'] = step_val
      self._vals['avg_steps_for_min_error_err'] = step_err
    
    else:
      loss_val = self._vals['avg_min_error']
      loss_err = self._vals['avg_min_error_err']
      diff_val = self._vals['avg_diff_for_min_error']
      diff_err = self._vals['avg_diff_for_min_error_err']
    
    sep = self.get_description()['separation_ratio']
    return diff_val, diff_err, loss_val, loss_err, sep

  def get_n_steps_vs_min_error(self):
    """Returns a min error and number of steps to achieve this min loss."""
    if self._vals['avg_min_error'] is None:
      _ = self.get_diffusion_vs_min_error()

    loss_val = self._vals['avg_min_error']
    loss_err = self._vals['avg_min_error_err']
    step_val = self._vals['avg_steps_for_min_error']
    step_err = self._vals['avg_steps_for_min_error_err']
    sep = self.get_description()['separation_ratio']

    return step_val, step_err, loss_val, loss_err, sep

  def get_sep_ratio_vs_min_error(self):
    if self._vals['avg_min_error'] is None:
      _ = self.get_diffusion_vs_min_error()

    loss_val = self._vals['avg_min_error']
    loss_err = self._vals['avg_min_error_err']
    sep = self.get_description()['separation_ratio']

    return sep, loss_val, loss_err

  def get_sep_ratio_vs_accept_ratio(self):
    """Returns a tuple (`sep_ratio`, `accept_ratio`, `stddev`)."""
    
    sep = self.get_description()['separation_ratio']
    acc = self.get_accept_ratio()
    stddev = self._vals['accept_ratio_err']

    return sep, acc, stddev

  def get_sep_ratio_vs_mix_ratio(self):
    """Returns a tuple (`sep_ratio`, `mix_ratio`, `stddev`)."""
    sep = self.get_description()['separation_ratio']
    mix = self.get_mix_ratio()
    stddev = self._vals['mix_ratio_err']

    return sep, mix, stddev

  def get_sep_ratio_vs_visit_ratio(self):
    """Returns a tuple (`sep_ratio`, `visit_ratio`, `stddev`)."""

    sep = self.get_description()['separation_ratio']
    visit = self.get_visit_ratio()
    stddev = self._vals['visit_ratio_err']

    return sep, visit, stddev

  def show_report(self, simulation_num=0, sample_every=3):
    """Shows the report of the simulation with plots."""
    sep, acc, stddev = self.get_sep_ratio_vs_accept_ratio()
    print('Accept Ratio:', acc, '+/-', stddev)

    sep, visit, stddev = self.get_sep_ratio_vs_visit_ratio()
    print('Visit Ratio:', visit, '+/-', stddev)

    sep, mix, stddev = self.get_sep_ratio_vs_mix_ratio()
    print('Mixing Ratio:', mix, '+/-', stddev)

    sep, loss_val, loss_err = self.get_sep_ratio_vs_min_error()
    print('Min Error value:', loss_val, '+/-', loss_err)
    
    print()
    _ = self._plot_loss(simulation_num=simulation_num)
    _ = self._plot_loss(summ_name='train_loss',
                        simulation_num=simulation_num,
                        sample_every=sample_every)
    _ = self._plot_error(simulation_num=simulation_num)
    _ = self._plot_error(summ_name='train_error',
                         simulation_num=simulation_num,
                         sample_every=sample_every)
    _ = self._plot_diffusion(simulation_num=simulation_num)
    _ = self._plot_mixing(simulation_num=simulation_num)
    _ = self._plot_grads(simulation_num=simulation_num,
                         sample_every=sample_every)
    _ = self._plot_norms(simulation_num=simulation_num)

  def get_accept_ratio(self):
    accepts = []
    if self._vals['accept_ratio'] is None:
      for s in range(self._n_simulations):
        for r in range(self._n_replicas):
          x, y = self.get_summary('accepts', replica_id=r, simulation_num=s)
          accepts.append(np.mean(y))
      self._vals['accept_ratio'] = np.mean(accepts)
      self._vals['accept_ratio_err'] = np.std(accepts)

    return self._vals['accept_ratio']

  def get_mix_ratio(self):
    if self._vals['mix_ratio'] is None:
      keys = [float("{0:.4f}".format(b))
              for b in self.get_description()['noise_list']]

      def _get_key(key):
        return keys[int(np.argmin([abs(k-key) for k in keys]))]

      mixing = {i:[] for i in range(self._n_replicas)}
      visiting = {i:[] for i in range(self._n_replicas)}
      travel_times = []
      for s in range(self._n_simulations):

        for r in range(self._n_replicas):
          x, y = self.get_summary('noise_values', replica_id=r, simulation_num=s)
          steps = self.get_summary('train_steps', replica_id=r, simulation_num=s)

          reps = {k:0 for k in keys}

          for i in range(len(steps[1])):
            if steps[1][i] > self.get_description()['burn_in_period']:
              reps[_get_key(y[i])] += 1

          visiting[r].append(np.mean([1 if reps[x]!=0 else 0 for x in reps]))
          mixing[r].append(1 if all(reps[x]!=0 for x in reps) else 0)

      mix_ratios = []
      visit_ratios = []
      for s in range(self._n_simulations):
        mix_ratio = np.mean([mixing[r][s] for r in range(self._n_replicas)])
        visit_ratio = np.mean([visiting[r][s] for r in range(self._n_replicas)])
        mix_ratios.append(mix_ratio)
        visit_ratios.append(visit_ratio)
      self._vals['mix_ratio'] = np.mean(mix_ratios)
      self._vals['visit_ratio'] = np.mean(visit_ratios)
      self._vals['mix_ratio_err'] = np.std(mix_ratios)
      self._vals['visit_ratio_err'] = np.std(visit_ratios)

    return self._vals['mix_ratio']

  def get_visit_ratio(self):
    if self._vals['visit_ratio'] is None:
      _ = self.get_mix_ratio()
    return self._vals['visit_ratio']

  def get_summary(self, summ_name, replica_id=0, simulation_num=0):
    if simulation_num >= self._n_simulations:
      raise ValueError('No such simulation.')
    if 'steps' in summ_name:
      y = self._summaries[simulation_num][summ_name]
    else:
      y = self._summaries[simulation_num][summ_name][replica_id]
    n_epochs = self._summaries[simulation_num]['latest_epoch'] + 1
    try:
      x = np.linspace(start=0,
                      stop=n_epochs,
                      num=len(y))
    except TypeError:
      print(summ_name, y)
      raise
    return x, y

  def get_description(self):
    return self._description

  def _plot_norms(self, simulation_num=0):
    fig, ax = plt.subplots()
    plot = Plot()
    for r in range(self._n_replicas):
      x, y = self.get_summary('weight_norms', r, simulation_num)
      plot.plot(x, y, fig=fig, ax=ax, label='replica ' + str(r),
                linewidth=2)
    plot.legend(fig, ax, legend_title='ReplicaID',
                xlabel='EPOCHS', ylabel='WEIGHT L2 NORM')
    return fig

  def _plot_diffusion(self, simulation_num=0):
    fig, ax = plt.subplots()
    plot = Plot()
    for r in range(self._n_replicas):
      x, y = self.get_summary('diffusion', r, simulation_num)
      plot.plot(x, y, fig=fig, ax=ax, label='replica ' + str(r),
                linewidth=2)

    plot.legend(fig, ax, legend_title='ReplicaID',
                xlabel='EPOCHS', ylabel='DIFFUSION')
    return fig

  def _plot_grads(self, simulation_num=0, sample_every=1):
    fig, ax = plt.subplots()
    plot = Plot()
    for r in range(self._n_replicas):
      x, y = self.get_summary('grad_norms', r, simulation_num)
      x, y = x[::sample_every], y[::sample_every]
      plot.plot(x, y, fig=fig, ax=ax, label='replica ' + str(r),
                linewidth=1.5)

    plot.legend(fig, ax, legend_title='ReplicaID',
                xlabel='EPOCHS', ylabel='GRADIENT L2 NORM', log_y=5)

    return fig

  def _plot_loss(self, summ_name='test_loss', simulation_num=0, sample_every=1):
    fig, ax = plt.subplots()
    plot = Plot()
    for r in range(self._n_replicas):
      x, y = self.get_summary(summ_name, r, simulation_num)
      x, y = x[::sample_every], y[::sample_every]
      plot.plot(x, y, fig=fig, ax=ax, label='replica ' + str(r),
                linewidth=2, splined_points_mult=None)

    plot.legend(fig, ax, legend_title='ReplicaID',
                xlabel='EPOCHS', ylabel='LOSS', ylimit=(0, 9))

  def _plot_error(self, summ_name='test_error', simulation_num=0, sample_every=1):
    fig, ax = plt.subplots()
    plot = Plot()
    for r in range(self._n_replicas):
      x, y = self.get_summary(summ_name, r, simulation_num)
      x, y = x[::sample_every], y[::sample_every]
      label = 'replica_' + str(r) + ': min_err=' + "{0:.2f}".format(min(y))
      plot.plot(x, y, fig=fig, ax=ax, label=label,
                linewidth=2, splined_points_mult=None)

    plot.legend(fig, ax, legend_title='ReplicaID',
                xlabel='EPOCHS', ylabel='0-1 ERROR')

  def _plot_mixing(self, simulation_num=0):
    def _get_key(key):
      keys = [float("{0:.4f}".format(b))
              for b in self.get_description()['noise_list']]
      return keys[int(np.argmin([abs(k-key) for k in keys]))]

    fig, ax = plt.subplots()
    plot = Plot()
    noise_list = self.get_description()['noise_list']

    key_map = {_get_key(key):i for i, key in enumerate(noise_list)}
    for r in range(self._n_replicas):
      x, y = self.get_summary('noise_values', replica_id=r, simulation_num=simulation_num)

      y_new = [key_map[_get_key(i)] for i in y]
      plot.plot(x, y_new, fig=fig, ax=ax, label='replica ' + str(r),
                linewidth=2)
    yticks_names = [float("{0:.4f}".format(b)) for b in noise_list]

    plt.gca().set_yticklabels(['0'] + yticks_names)
    plot.legend(fig, ax, legend_title='ReplicaID',
                xlabel='EPOCHS', ylabel='NOISE LEVEL')
    return fig

def _find_nearest_idx(array, value):
  """Returns the index of the closest to the `value` value in `array`."""
  array = np.asarray(array)
  idx = (np.abs(array-value)).argmin()
  return idx